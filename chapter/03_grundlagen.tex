\chapter{Grundlagen}

\section{Client/Server Model}
\label{sec:client_server}

Webanwendungen sind eine erweiterte Form von normalen Webseiten und funktionieren nach den selben Prinzipien des World Wide Webs. Diesen liegt wiederum das Client-/Server-Model zu Grunde.

Der Client ist ein Programm des Benutzers und ist dafür zuständig, den Inhalt der Applikation oder Webseite auf dem Bildschirm in benutzerfreundlicher Art und Weise zu verarbeiten. Ein solcher typischer Client ist der Web Browser.

Der Inhalt selbst befindet sich auf einem entfernten Rechner, genannt der Server. Server verarbeiten eingehende Anfragen der Clients nach Inhalten und liefern eine Kopie dieser Inhalte aus. Der heruntergeladene Inhalt kann schließlich vom Client angezeigt werden.

Die Fachbezeichnung für den remote Inhalt ist Ressource. Ressourcen können aus Bildern, Videos, Webseiten und andere Dateien bestehen. Aber wie am Anfang angedeutet, sind Ressourcen nicht nur auf Dateien und Webseiten beschränkt. Sie können auch in Form vom Software vorkommen, welche es z.B. erlauben, Aktien zu handeln oder Videospiele zu spielen. Ressourcen werden dabei durch einen eindeutigen Bezeichner - die URL - identifiziert.

Ein simples Diagramm, wie Client und Server interagieren können, sieht wie folgt aus:

Historisch ergeben, nutzen Client und Server das Kommunikationsprotokoll HTTP für die Kommunikation untereinander. Diese Übertragung ist zustandslos. Diese Eigenschaft wurde absichtlich konzipiert, um die Protokoll-Implementierung einfach zu halten und um Serverressourcen zu sparen. Der Server muss dabei keine Benutzerinformation zwischen den Anfragen merken. Im Fehlerfall muss ebenfalls nichts aufgeräumt werden. Die beiden Gründe machen HTTP zu einem sehr belastbaren Protokoll, aber auch gleichzeitig zu einem schwierigen Protokoll, um zustandsbehaftete Webanwendungen zu implementieren.

\cite[Background]{Parikh:2015} beschreibt das Problem wie folgt:

"When you go to Facebook, for example, and log in, you expect to see the internal Facebook page. That was one complete request/response cycle. You then click on the picture -- another request/response cycle -- but you do not expect to be logged out after that action. If HTTP is stateless, how did the application maintain state and remember that you already input your username and password? In fact, if HTTP is stateless, how does Facebook even know this request came from you, and how does it differentiate data from you vs. any other user? There are tricks web developers and frameworks employ to make it seem like the application is stateful..."

D.h, dass es eine Reihe von verschiedenen Techniken gibt, welche auf Anwendungsebene realisiert werden müssen, um Zustandshaftigkeit in einem zustandslosen Protokoll zu gewährleisten.

Vgl. \cite[Background]{Parikh:2015}, \cite{Culloca:2006}

\section{HTTP}

In \ref{sec:client_server} wurde erwähnt, dass im World Wide Web das Kommunikationsprotokoll HTTP verwendet wird. Ein Protokoll zeichnet sich zunächst durch 3 grundlegende Eigenschaften aus:

\begin{itemize}
\item Syntax - Datenformat und Kodierung
\item Semantik - Steuerungsinformation und Fehlerbehandlung
\item Zeitablauf - Geschwindigkeitsanpassung und Reihenfolge
\end{itemize}

\cite{Dubost:2012} zeigt, dass Kommunikationsprotokolle nicht nur ein künstliches Konstrukt sind, sondern auch aus der realen Welt stammen:

"When two people meet, they engage using a communication protocol: for example, in Japan, a person will make a specific gesture with the body. One such gesture is a bow, which is the syntax used for the interaction. In Japanese customs, the gesture of the bow (among others) is associated with the semantics of greeting someone. Finally, when one person bows to another person, a sequence of events has been established between the two in a specific timing."

Weiterhin beschreibt \cite{Dubost:2012}, dass in einem Online-Kommunikationsprotokoll die gleichen Elemente vorkommen: die Syntax - die Abfolge von Zeichen, etwa Bezeichnern, die für das Schreiben des Protokolls verwendet werden; die Semantik - die Bedeutung, die mit diesen Bezeichnern assoziiert wird; und schließlich der Zeitablauf - eine vorgegebene Reihenfolge, in der Client und Server diese Bezeichner austauschen.

HTTP ist dabei ein sog. Application Level Protocol, d.h, dass es in der Abstraktionsebene höher angesiedelt ist. Es setzt wiederum auf eine Reihe weiterer Protokolle auf, welche sich etwa um die Übertragung der eigentlichen Datenpakete oder die physikalische Übertragung der elektrischen Signale kümmern. HTTP selbst beschreibt hingegen die Bedeutung und das Format der gesamten übertragenen Nachricht.

Folgend ist eine HTTP GET Anfrage aufgelistet:

\begin{listing}[H]
\begin{minted}{http}
GET / HTTP/1.1
Host: www.opera.com
User-Agent: Opera
\end{minted}
\caption{HTTP GET Request}
\end{listing}

Diese Nachricht spezifiziert, dass der Client eine Ressource erhalten möchte.
Die Ressource, die der Client erhalten möchte, befindet sich im root-Verzeichnis.
Die Übertragung soll mittels HTTP version 1.1 stattfinden. Der Client versucht eine spezifische Webseite zu erreichen, die sich unter der URL \emph{www.opera.com}befindet. Ferner teilt der Client einen sog. HTTP Header, namens \emph{User-Agent} Informationen über das Programm, welches für die Kommunikation verwendet wurde.

Eine Antwort vom Server könnte dabei wie folgt aussehen:

\begin{listing}[H]
\begin{minted}{http}
HTTP/1.1 200 OK
Date: Wed, 23 Nov 2011 19:41:37 GMT
Server: Apache
Content-Type: text/html; charset=utf-8
Set-Cookie: language=none; path=/; domain=www.opera.com;
  expires=Thu, 25-Aug-2030 19:41:38 GMT
Set-Cookie: language=en; path=/; domain=.opera.com;
  expires=Sat, 20-Nov-2030 19:41:38 GMT
Vary: Accept-Encoding
Transfer-Encoding: chunked

<!DOCTYPE html>
<html lang="en">
…
\end{minted}
\caption{HTTP GET Response}
\end{listing}

Der Server antwortet, dass er das Protokoll HTTP Version 1.1 versteht. Die Anfrage war erfolgreich und wurde daher mit dem Response Code 200 sowie einer verständlichen Annotation \textit{OK} versehen. Anschließend wird eine Reihe weiterer HTTP Header gesendet, welche beschreiben, wie die Nachricht verstanden werden soll. Und letzendlich wird der Inhalt der Ressource - hier ein HTML Dokument - in den Rumpf (body) der Nachricht eingefügt.

Weitere HTTP-Methoden sind: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT.
Jede von denen hat eine unterschiedliche Rolle. Siehe \cite[Kap. 4]{Fielding:2014}. 

Vgl. \cite{Dubost:2012}

\section{Serverseitige Webanwendungen}

\subsection{Grundprinzip}

Als das World Wide Web geboren wurde, existierte nur ein Webserver und ein Webclient. Dieser Webserver namens httpd war nur in der Lage, statische Ressourcen wie Bilder und Dokumente auszuliefern. Schon bald jedoch machte der Überfluss an Online-Ressourcen Suchmaschinen notwendig. Das bedeutete, dass Benutzer in der Lage sein mussten, Daten, wie den Suchbegriff, an den Server abzuschicken und der Server seinerseits im Stande sein sein musste, diese Daten zu verarbeiten und dynamisch entsprechende Inhalte zu liefern.

Hierfür wurde das Common Gateway Interface (CGI) spezifiziert. Es entwickelte sich zum Standard, um externe Applikationen mit Webservern zu verbinden und um dynamische Information zu generieren. Ein CGI Programm kann beinahe in jeder Programmiersprache implementiert werden. Es muss nur die Fähigkeit besitzen, sein vom STDIN zu lesen und auf STDOUT zu schreiben.

Folgend ist ein exemplarisches CGI "Hello World" Programm dargestellt. Ein Benutzer namens Doug gibt seinen Namen ein, welcher vom Webserver ausgegeben werden soll. Dabei generiert sein Webclient einen HTTP GET Request an folgende URL:

\begin{minted}{http}
http://example.com/cgi-bin/hello.pl?username=Doug
\end{minted}

Wenn der Webserver diese Anfrage bekommt, weiß er, wie er die URL in zwei Teile trennt: den Pfad zu dem CGI Perl Programm \emph{hello.pl} und den Teil mit der Benutzereingabe (username=Doug, genannt QUERY\_STRING). Er leitet also diese Anfrage über STDIN an das \emph{hello.pl} Script weiter. Die Aufagbe des Scriptes ist nun, den QUERY\_STRING nach dem Schlüssel \emph{username} zu parsen und dessen Wert über SDTOUT auszugeben. Der Webserver wird wiederum diese Ausgabe an den Client weiterleiten. Das Beispiel "Hello user" Programm ist in \ref{lst:hello_pl} abgebildet.

\begin{listing}[H]
\begin{minted}{perl}
  #!/usr/bin/perl

  use CGI qw(:standard);
  my $username = param('username') || "unknown";

  print "Content-type: text/plain\n\n";
  print "Hello $username!\n";
\end{minted}
\caption{"Hello user" CGI script}
\label{lst:hello_pl}
\end{listing}

Ein solches serverseitiges Programm generiert für gewöhnlich dynamische Inhalte, indem es die Information dafür aus einer Datenbank bezieht. Heutige serverseitige Webanwendungen nutzen weiterhin entweder eine Weiterentwicklung der CGI Schnittstelle oder ein ähnliches Prinzip.

Vgl. \cite[Kap. 1.1]{Bekman:2003}

Im Kapitel \ref{sec:client_server} wurde auf die Diskrepanz hingewiesen, dass HTTP ein zustandsloses Protokoll ist, eine Webanwendung jedoch Zustandshaftigkeit benötigt, um Benutzersitzungen, etwa Besuch und Einkauf in einem Webshop, auseinanderzuhalten. Eine solche Session kann von dem Client und Server Programm
künstlich aufrecht erhalten werden.

Dabei generiert das serverseitige Programm einen Session-Identifier beim ersten Besuch des Benutzers und sendet es an den Client. Der Client wiederum sendet diese  ID bei jeder weiteren Anfrage an den Server mit. Ein Mechanismus für die Benutzersessions im Web ist das Setzen von HTTP-Cookies, welche dann automatisch bei den nachfolgenden Anfragen angehängt werden. Weitere manuelle Möglichkeiten sind  Übertragung mittels custom HTTP Header oder Umwandeln der URLs durch das Anhängen des zusätzlichen \emph{session\_id} Parameters.

Siehe \cite[Stateful Web Applications]{Parikh:2015}

\subsection{Architektur}

In objektorientierter Software ist für die Erstellung von graphischen Anwendungen das Model-View-Controller Pattern vorherrschend.

Galilio schreibt: "Mit Model-View-Controller (MVC) wird ein Interaktionsmuster in der Präsentationsschicht von Software beschrieben. MVC ist wohl einer der schillerndsten Begriffe im Bereich der objektorientierten Programmierung. Viele Varianten haben sich herausgebildet, teilweise einfach aufgrund eines falschen Verständnisses des ursprünglichen MVC-Musters, teilweise als Weiterentwicklung oder Anpassung an neue Anwendungsfälle."

Unabhängig von der jeweiligen Abwandlung des MVC Pattern gilt, dass der Controller für Benutzereingaben, das Model für den Zustand und der View für das Darstellen dieses Zustands verantwortlich ist. Vgl. Galilio  8.2.3

Serverseitige Webanwendungen interpretieren MVC wie folgt. Benutzerinteraktionen führen weitgehend zu Anfragen einer komplett neuen Ressource, e.g:

\begin{minted}{http}
GET http://example.com/articles
GET http://example.com/articles/1
GET http://example.com/articles/1/comments
\end{minted}

Jeder ankommende HTTP Request wird von einem bestimmten Controller verarbeitet. Dieser liest HTTP Header sowie Request Parameter aus und verwendet Model Objekte, um die notwendige Daten für eine Benutzeranfrage zu liefern. Models laden diese Daten üblicherweise aus einer Datenbank. Und schließlich generiert der Controller die gesamte Seite neu, welche sich nur um den neuen Inhalt von der vorherigen unterscheidet, dessen Layout, Menüs, Header etc. aber gleich bleiben. Hierfür wird eine HTML-Template-Engine und ein passendes Template - das View - verwendet. Dieses stellt im Grunde ein HTML-Markup mit Platzhaltern für dynamische Daten dar, welche vom Controller durch die Model-Daten ersetzt werden. Dieses stellt im Grunde HTML Markup mit Platzhaltern für dynamische Daten dar, welche vom Controller durch die Model Daten ersetzt werden. Siehe \ref{fig:server_side_mvc}

\begin{figure}[htp]     % h=here, t=top, b=bottom, p=page
\centering
\includegraphics[width=1.0\textwidth]{images/server_side_mvc} 
\caption{Serverseitiges MVC}\label{fig:server_side_mvc}
\end{figure}

\section{Clientseitige Webanwendungen}

\subsection{Grundprinzip}

In dem Aufsatz, der den Namen \emph{Ajax} geprägt hat, schrieb \cite{Garrett:2005}: "The classic web application model works like this: Most user actions in the interface trigger an HTTP request back to a web server. The server does some processing — retrieving data, crunching numbers, talking to various legacy systems — and then returns an HTML page to the client. It’s a model adapted from the Web’s original use as a hypertext medium, but as fans of The Elements of User Experience know, what makes the Web good for hypertext doesn’t necessarily make it good for software applications."

Schon in den 90er Jahren implementierten Browserhersteller Skripting Möglichkeiten für Webseiten. Es enstand die Möglichkeit, Programmcode an den Client Rechner zusammen mit dem Markup auszuliefern, um interaktive Animationen auf der Webseite auszulösen. Die Programmiersprache Javascript war geboren. Sie wurde später unter dem Begriff ECMAScript standardisiert.

Im weiteren Verlauf ermöglichte die Implementierung der XMLHttpRequest Schnittstelle, HTTP Anfragen aus Javascript unabhängig von dem Browser Client auszuführen. Dies legte den Grundstein für die von Garret unter dem Begriff \emph{Ajax} zusammengefasste Sammlung von Techniken und somit die Enstehung echter clientseitiger Webanwendungen.

So schreibt \cite{Garrett:2005} weiter: \enquote{Ajax isn`t a technology. It`s really several technologies, each flourishing in its own right, coming together in powerful new ways.} Und er definiert die Komponenten, welche Ajax ausmachen.

\begin{itemize} 
\item standards-basierte Darstellung, unter Verwendung von XHTML und CSS 
\item dynamische Darstellung und Interkation, unter Verwendung des Document Object Model
\item Datenaustausch und Manipulation mit Hilfe von XML und XSLT
\item Asynchrone Datenabfragen, unter Verwendung des XMLHttpRequest
\item Javascript, welches das Ganze zusammenbindet
\end{itemize}

Anstatt eine Webseite am Anfang der Benutzersitzung zu laden, lädt der Browser eine Ajax Engine - implementiert in Javascript. Diese Engine ist sowohl verantwortlich für das Rendern des Benutzerinterfaces als auch für die Kommunikation zwischen dem Server seitens des Benutzers. 

Die von Garret formulierten Ajax Bestandteile gelten noch heute. Allerdings spielt das Datenformat XML keine primäre Rolle. Es ist kein bestimmtes Datenaustausch Format vorgeschrieben, wobei überwiegend das kompakte JSON Format zur Übertragung benutzt wird. Der Schnittstellen Name - XMLHttpRequest blieb aus Kompatibilitätsgründen erhalten. Ab ECMAScript6 existiert eine neue HTTP Api, namens \emph{fetch}.

Vgl. \cite{Garrett:2005}

\subsection{Datenübetragung}

Die meist konventionelle Art und Weise, in der Ajax Applikationen mit dem Server kommunizieren, ist eine sog. REST Api. REST steht für representational state transfer.    

\begin{itemize} 
\item \emph{representational} bezieht sich darauf wie eine Representation eine Ressource übertragen wird.
\item \emph{state transfer} bezieht sich darauf dass HTTP ein zustandsloses Protokol ist und dass alles was der Server braucht, um eine Anfrage zu verarbeiten, sich in der Anfrage selbst befindet.
\end{itemize}

Die Grundideen hinter REST wurden auf den Beobachtungen dessen basiert, wie das Web bereits funktionierte. Das Laden von Webseiten, das Absenden von Formularen und das Benutzen von Links, um verwandte Inhalte zu finden sind Faktoren, welche definieren, was REST ist und wie es auf das Web und den Schnittstellen Design zutrifft. 

Alle Aktionen innerhalb REST konzentrieren sich also um Ressourcen und somit stellen das Erzeugen (Create), Lesen (Read), Aktualisieren ( Update) und Löschen (Delete) die einzigen Aktionen da, welche auf diese Ressourcen angewendet werden. Das Akronym welches diese vier Aktionen beschreibt ist demnach \emph{CRUD}. Beispielweise würde innerhalb des REST Paradigma, um einen Benutzer einzuloggen, nicht etwa eine Remote Procedure \emph{User.login(username, password)} aufgerufen, sondern eine Ressource \emph{UserSession} mit den Attributen \emph{username, password} auf dem Server erstellt.

Eine anschauliche Art REST Schnittstellen zu Implementieren ist alle Aktion auf zwei Kriterien zu brechen 

\begin{itemize}
 \item \emph{Was} - Auf welche Ressource wird eingewirkt ?
 \item \emph{Wie} - Was passiert mit der Ressource ?
\end{itemize}
 
Folgend ist tabelarisch die Akzentuirung des "Was" und des "Wie" auf den Design einer REST API für den Benutzerlogin dargestellt.

\begin{center}
    \begin{tabular}{ | p{5cm} | l | l | l | l |}
    \hline
    \multirow{2}{*}{Zielsetzung} & \multicolumn{2}{l|}{ Wie } & \multicolumn{2}{l|}{ Was } \\ \cline{2-5} 
    & Operation & HTTP Methode & Ressource & Pfad \\ \hline
    Information über die Session  bekommen & Read & GET & Session & /sessions/:id \\ \hline
    Eine neue Session erzeugen ( Benutzer einloggen ) & Create & POST & Sessions Liste & /sessions \\ \hline
    Neue Daten zur Session hinzufügen & Update & PUT & Session & /sessions/:id \\ \hline
    Session löschen ( Benutzer ausloggen ) & Delete & DELETE & Session & /sessions/:id \\ \hline  
    \end{tabular}
\end{center}

Vgl. \cite[Kap. REST and CRUD]{LaunchSchool:2016}

\subsection{Architektur}

Clientseitige Webanwendungen verzichten durchgehend auf komplette Page Loads bei Benutzerinteraktionen. Sie reagieren auf Eingaben, indem sie das Document Object Model (DOM) der Website im Speicher direkt verändern und somit ein Neurendern der betroffenen Teilbereiche auslösen. Anstelle des kompletten Markups werden lediglich die notwendigen neuen Daten in einem serialisierten Format vom einem Webservice angefragt über eine definierte API abgefragt. 

Auch hier wird bei einer objektorientierten Umsetzung das MVC Pattern bzw. eine Abwandlung davon verwendet. Dabei werden Benutzereingaben direkt von einem dafür zuständigen Controller verarbeitet. Der Controller leitet die Anfrage an das Model weiter, welches mit einem Webservice interagieren kann. Anschließend benachrichtigt der Controller das View über die Änderung des Zustands der Applikation. Schließlich sorgt das View für die direkte DOM Manipulation eines bestimmten Teilbereich der Seite.
Siehe \ref{fig:client_side_mvc}.

\begin{figure}[htp]     % h=here, t=top, b=bottom, p=page
\centering
\includegraphics[width=1.0\textwidth]{images/client_side_mvc} 
\caption{Clientseitiges MVC}\label{fig:client_side_mvc}
\end{figure}

Die meisten clientseitigen Frameworks führen eine Technik namens ``Databinding'' ein. Dabei wird, einst aus einem Markup Template erstelltes, View an bestimmte Datenfelder in einem Model angebunden. Das View aktualisiert sich mit der Zustandsänderung des Models automatisch. Somit bleibt kaum noch Eventverarbeitungs Aufwand für einen typischen Controller notwendig, weswegen dieser eher als Presenter (siehe \cite{MSDN:2016:MVP}) oder sog. ViewModel (siehe \cite{MSDN:2016:MVVM}) verstanden werden kann.


\section{Responsive Webdesign}

\cite[S.8]{Marcotte:2011} führt den Beggriff Responsive Webdesign mit folgenden Worten ein:

\enquote{But web designers, facing a changing landscape of new devices and contexts, are now forced to overcome the constraints we’ve imposed on the web’s innate  exibility.
We need to let go.
Rather than creating disconnected designs, each tailored to a particular device or browser, we should instead treat them as facets of the same experience. In other words, we can craft sites that are not only more  exible, but that can adapt to the media that renders them.
In short, we need to practice responsive web design}

Hierfür legte Marcotte 3 Grundelemente fest:

\begin{itemize}
 \item Flexibles, rasterbasiertes Layout
 \item Flexible Bilder und Medien
 \item Media Queries, ein Modul aus der CSS3 Spezifikation
\end{itemize}

Üblicherweise platzieren Webdesigner die Webseitenelemente auf ein imaginäres Raster. Somit sind bestimmte Komponenten aneinander anhand dieser virtuellen Linien ausgerichtet. In Abb. \ref{fig:grid} sieht man ein solches Raster. Das Design besteht hier aus zwei Textspalten \emph{main} - 566px breit und \emph{other} - 331 px breit. Diese befinden sich wiederum in einem umschließendem  \emph{blog} 900 px Container, welcher wiederum in den \emph{page} Container eingebunden ist. Die Elemente definieren entsprechende Abstände (\emph{margin} ), so dass aus Breite der Elemente und der Abstände sich eine Textpositionierung anhand der virtuellen Grid Linien ergibt, wie in der Abb dargestellt.

\begin{figure}[htp]     % h=here, t=top, b=bottom, p=page
\centering
\includegraphics[width=1.0\textwidth]{images/grid} 
\caption{Webdesign Raster}\label{fig:grid}
\end{figure}

Das obige Layout kann durch folgenden CSS code erzeugt werden:

\begin{listing}[H]
\begin{minted}{css}
  #page {
    margin: 36px auto;
    width: 960px;
  }
  .blog {
    margin: 0 auto 53px;
    width: 900px;
  }
  .blog .main {
    float: left;
    width: 566px;
  }
  .blog .other {
    float: right;
    width: 331px;
  }
\end{minted}
\caption{Raster CSS}
\label{lst:grid_css}
\end{listing}

Um nun von einem starren Raster auf ein flexibles Raster zu kommen, welches sich an Bildschirmgrößen anpasst, werden feste Pixel Angaben durch relative Prozentangaben ersetzt. Hierfür wird eine einfach Umrechnungsformel verwendet - $target / context = result$

Wenn also sich das Target Element \emph{main} mit 566px Breite sich bei einem festen Raster innerhalb des Kontextelementes \emph{blog} mit 900px Breite befindet, ergibt sich dafür laut $566 / 900$ eine 62.8888889\% Breite:
 
\begin{listing}[H]
\begin{minted}{css}
  .blog .main {
    float: left;
    width: 62.8888889%;
  }
\end{minted}
\caption{Flexibles Raster CSS}
\label{lst:flex_grid_css}
\end{listing}

Im Prinzip wird die obige Umrechnung auf alle festen Breiten-, Abstand- und Fontgrößen Angaben angewendet. Daraus ergibt sich ein anpassbares Raster(siehe Abb. \ref{fig:flex_grid}).

\begin{figure}[htp]     % h=here, t=top, b=bottom, p=page
\centering
\includegraphics[width=1.0\textwidth]{images/flex_grid} 
\caption{Flexibles Webdesign Raster}\label{fig:flex_grid}
\end{figure}

Bezüglich flexibler Bilder und Medien verhält es sich ähnlich, wie mit dem Grundansatz des flexiblen Rasters. Werden Bilder in Markup Container eingebettet, so sollte dieser Container sine Abstände sowie Breite widerum relativ zu seinem Contexcontainer gesetzt haben. Siehe Listing. 

\begin{listing}[H]
\begin{minted}{html}
<div class="figure">
  <p>
    <img src="robot.jpg" alt="" />
    <b class="figcaption">Lo, the robot walks</b>
  </p>
</div>
\end{minted}
\caption{Container mit Bild Markup}
\label{lst:image_container_markup}
\end{listing}
 
\begin{listing}[H]
\begin{minted}{css}
 .figure {
    float: right;
    margin-bottom: 0.5em;
    margin-left: 2.53164557;
    width: 48.7341772%;
}
\end{minted}
\caption{Container mit Bild CSS}
\label{lst:image_container_css}
\end{listing}

Diese Einstellung allein wird aber nicht ausreichen. Sollte das Bild in Wirklichkeit größer sein, als sich Platz dafür resultierend aus der dynamischen Breitenangabe und der jeweiligen Gerätauflösung ergibt, wird es standardmäßig mit Scrollbalken innerhalb seines Containers in original Größe gerendert.

Die Lösung dieser Problematik hängt von dem gewünschten Effekt ab. In vielen Fällen wird einfach das Gleiche Skalierverhlaten für das Bild gewünscht, wie für den Rest des Inhalts. Hierfür sorgt eine \emph{max-width: 100\%} Einstellung auf das Bildelement selbst. 

\begin{listing}[H]
\begin{minted}{css}
.figure {
    float: right;
    margin-bottom: 0.5em;
    margin-left: 2.53164557;
    width: 48.7341772%;
}

.figure img {
  max-width: 100%;
}
\end{minted}
\caption{Bildskalierung}
\label{lst:scalable_image}
\end{listing}


Es kann aber auch ausreichen sein, dass einfach ein bestimmter Bildausschnitt gerendert wird, so im Falle von Hintergrundbildern. Dieses wird mit Hilfe einer \emph{overflow: hidden\%} css Regel erreicht auf dem Context Container des Bildes erreicht. 

\begin{listing}[H]
\begin{minted}{css}
.figure {
  overflow: hidden;
}
.feature img {
  display: block;
  max-width: auto;
}
\end{minted}
\caption{Bildausschnitt}
\label{lst:cropped_image}
\end{listing}

Denkbar wäre auch die Absicht ein komplett anderes, eventuell ähnliches aber unterschiedlich arrangiertes Bild für kleinere Auflösungen zu laden, im Falle von Grafiken beispielsweise. Dieses erfordert jedoch eine zusätzliche Implementierung auf der Serverseite.

In dieser Arbeit wird eine weitere Technik für den Fotoslider geschildert, wobei das Foto nicht nur mit dem Inhalt skalieren, sondern ebenfalls zentriert sein muss.


