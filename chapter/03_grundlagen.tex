\chapter{Grundlagen}

\section{Client/Server Model}
\label{sec:client_server}

Webanwendungen sind eine erweiterte Form von normalen Webseiten und funktionieren nach den selben Prinzipien des World Wide Webs. Diesen liegt wiederum das Client/Server Model zu Grunde.

Der Client ist ein Programm des Benutzers und ist dafür zuständig den Inhalt der Applikation oder Webseite auf dem Bildschirm in benutzerfreundlicher Art und Weise zu verarbeiten. Ein solcher typischer Client ist der Web Browser.

Der Inhalt selbst befindet sich auf einem entfernten Rechner, genannt der Server. Server verarbeiten eingehende Anfragen der Clients nach Inhalten und liefern eine Kopie dieser Inhalte aus. Der heruntergeladene Inhalt kann schließlich vom Client angezeigt werden.

Die Fachbezeichnung für den remote Inhalt ist Ressource. Ressourcen können aus Bildern, Videos, Webseiten und andere Dateien bestehen. Aber wie am Anfang angedeutet sind Ressourcen nicht nur auf Dateien und Webseiten beschränkt. Sie können auch in Form vom Software vorkommen, welche es z.B. erlauben Aktien zu handeln oder Videospiele zu spielen. Ressourcen werden dabei durch einen eindeutigen Bezeichner - die URL - identifiziert.

Ein simples Diagramm, wie Client und Server interagieren können, sieht wie folgt aus:

Historisch ergeben, nutzen Client und Server das Kommunikationsprotokoll HTTP für die Kommunikation untereinander. Diese Übertragung ist zustandslos. Diese Eigenschaft wurde absichtlich konzipiert, um die Protokoll Implementierung einfach zu halten und um Server Ressourcen zu sparen. Der Server muss dabei keine Benutzerinformation zwischen den Anfragen merken. Im Falle von muss ebenfalls Nichts aufgeräumt werden. Die beiden Gründe machen HTTP zu einem sehr belastbaren Protokoll, aber auch gleichzeitig zu einem schwierigen Protokoll, um zustandsbehaftete Webanwendungen zu implementieren.

\citep[Background]{launchschool} beschreibt das Problem wie folgt:

"When you go to Facebook, for example, and log in, you expect to see the internal Facebook page. That was one complete request/response cycle. You then click on the picture -- another request/response cycle -- but you do not expect to be logged out after that action. If HTTP is stateless, how did the application maintain state and remember that you already input your username and password? In fact, if HTTP is stateless, how does Facebook even know this request came from you, and how does it differentiate data from you vs. any other user? There are tricks web developers and frameworks employ to make it seem like the application is stateful..."

D.h, dass es eine Reihe von verschiedenen Techniken gibt, welche auf Anwendungsebene realisiert werden müssen, um Zustandshaftigkeit in einem zustandslosen Protokoll zu gewährleisten.

Vgl. \citep[Background]{launchschool}, \citep{culloca}

\section{HTTP}

In \ref{sec:client_server} wurde erwähnt, dass im World Wide Web das Kommunikationsprotokoll HTTP verwendet wird. Ein Protokoll zeichnet sich zunächst durch 3 grundlegende Eigenschaften aus:

\begin{itemize} 
\item Syntax - Datenformat und Kodierung
\item Semantik - Steuerungsinformation und Fehlerbehandlung
\item Zeitablauf - Geschwindigkeitsanpassung und Reihenfolge
\end{itemize}

\citep{dubost} zeigt, dass Kommunikationsprotokolle nicht nur ein künstliches Konstrukt sind, sondern aus der realen Welt stammen: 

"When two people meet, they engage using a communication protocol: for example, in Japan, a person will make a specific gesture with the body. One such gesture is a bow, which is the syntax used for the interaction. In Japanese customs, the gesture of the bow (among others) is associated with the semantics of greeting someone. Finally, when one person bows to another person, a sequence of events has been established between the two in a specific timing."

Weiterhin beschreibt dubost, dass in einem online Kommunikationsprotokoll die gleichen Elemente vorkommen. Die Syntax, ist die Abfolge von Zeichen, etwa Bezeichnern die für das Schreiben des Protokolls verwendet werden. Die Semantik ist die Bedeutung, die mit diesen Bezeichnern assoziiert wird. Und schließlich der Zeitablauf ist eine vorgegeben Reihenfolge, in der Client und Server diese 
Bezeichner austauschen.

HTTP ist dabei ein sog. Application Level Protocol, d.h, dass es in der Abstraktionsebene höher angesiedelt ist. Es setzt wiederum auf eine Reihe weiterer Protokolle auf, welche sich etwa um die Übertragung der eigentlichen Datenpakete oder die physikalische Übertragung der elektrischen Signale kümmern. HTTP selbst beschreibt hingegen die Bedeutung und das Format der gesamten übertragenen Nachricht.

Folgend ist eine HTTP GET Anfrage aufgelistet:

\begin{listing}[H]
\begin{minted}{http}
GET / HTTP/1.1
Host: www.opera.com
User-Agent: Opera
\end{minted}
\caption{HTTP GET Request}
\end{listing}

Diese Nachricht spezifiziert, dass der Client eine Ressource erhalten möchte.
Die Ressource, die der Client erhalten möchte befindet sich im root-Verzeichnis
Die Übertragung soll mittels HTTP version 1.1 stattfinden. Der Client versucht eine spezifische Webseite zu erreichen, die sich unter der URL \textit{www.opera.com} befindet. Ferner teilt der Client einen sog. HTTP Header, namens \texit{User-Agent} Informationen über das Programm, welches für die Kommunikation verwendet wurde.

Eine Antwort vom Server könnte dabei wie folgt aussehen:

\begin{listing}[H]
\begin{minted}{http}
HTTP/1.1 200 OK
Date: Wed, 23 Nov 2011 19:41:37 GMT
Server: Apache
Content-Type: text/html; charset=utf-8
Set-Cookie: language=none; path=/; domain=www.opera.com; 
  expires=Thu, 25-Aug-2030 19:41:38 GMT
Set-Cookie: language=en; path=/; domain=.opera.com; 
  expires=Sat, 20-Nov-2030 19:41:38 GMT
Vary: Accept-Encoding
Transfer-Encoding: chunked

<!DOCTYPE html>
<html lang="en">
…
\end{minted}
\caption{HTTP GET Response}
\end{listing}

Der Server antwortet, dass er das Protokoll HTTP Version 1.1 versteht. Die Anfrage war erfolgreich und wurde daher mit dem Response Code 200 sowie für Menschen verständlichen Annotation \textit{OK} versehen. Anschließend wird eine Reihe weiterer HTTP Header gesendet, welche beschreiben, wie die Nachricht verstanden werden soll. Und Schließlich wird der Inhalt der Ressource - hier ein HTML Dokument - in den Rumpf (body) der Nachricht eingefügt.

Weitere HTTP Methoden sind: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT. 
Jede von denen hat eine unterschiedliche Rolle. Siehe \citep[Kap. 4]{http_spec}. 

Vgl. \citep{dubost}

\section{CGI}