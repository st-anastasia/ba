\chapter{Implementierung}

\section{Einleitung}

In Kapitel \ref{sec:zielsetzung} wurde als Zielsetzung bestimmt, dass diese Arbeit grundlegende Problemstellungen bei der Implementierung einer komplexen clientseitigen Webanwendung betrachtet. Ferner hat \ref{sec:client_side_web_apps} gezeigt, dass hierfür eine komplette \emph{Ajax-Engine} an den Client über HTTP ausgeliefert werden muss.

Für die Umsetzung dieser clientseitigen Architektur existiert eine Reihe von JavaScript Frameworks. Für die tatsächliche Implementierung der exemplarischen Software zur Fotoverwaltung verwendet diese Arbeit das AngularJS 1.x Framework. Dieses hält sich stark an die Konzepte objektorientierter Programmierung, liefert Bibliotheken zur Umsetzung des MVC-Patterns aus Kapitel \ref{sec:architecture} und eine Reihe weiterer für die Webbrowserumgebung relevanten Werkzeuge wie URL-Routing und DOM-Rendering.

Für die Umsetzung des Benutzerinterfaces wird das mit AngularJS kompatible Angular Material Framework verwendet. Dieses bringt Material Farbenpaletten, graphische Elemente und Layout Abstraktion als \gls{ng-directive} auf der Grundlage des CSS Flexbox Layouts mit vordefinierten CSS Media Queries für die Responsive Design Umgebung.

\section{Layout}

Die Haupt- und Akzentpalette lassen sich bei dem Einbinden von Angular Material einmalig konfigurieren. Die UI Komponenten setzen das Theming oft automatisch um.
Dort, wo es nicht passiert bzw. weitere Farbzustände für das Feedback bei Benutzerinteraktion benötigt werden, lassen sich über vorgegebene Parameter z.B. \emph{md-primary}, \emph{md-raised} die Zustände setzen bzw. per Databinding umschalten.

Für das Navigationsmenü (Abb. \ref{fig:gallery_large}, links) wird die \gls{ng-directive} \emph{md-sidenav} verwendet. Die Komponente bietet Schnittstellen zum Ein- und Ausklappen. Die Seitennavigation lässt sich parametrisiert entweder über den Inhalt legen oder kann den Inhalt wegschieben. Im Fall des Navigationsmenüs wird die erste Option verwendet.

Das Kontextmenü in der Tab-Leiste (Abb. \ref{fig:gallery_large}, oben) wird mit Hilfe des \emph{md-toolbar} Elements umgesetzt. Werkzeuge, welche nicht auf die Leiste passen, lassen sich mit \emph{md-menu-content} in ein Kontextmenü verstecken, welches erst beim Klicken erscheint.

Angular Material bringt ebenfalls Container Abstraktionen für das Anordnen der Elemente. Es existieren Zeilen (\emph{layout="row"}), Spalten (\emph{layout="column"}) und Gridcontainer (\emph{md-grid}), welche Elemente horizontal bzw. vertikal anordnen. Dieses wird intern  mit Hilfe von entsprechenden Flexbox-Eigenschaften umgesetzt. Die Container sorgen automatisch dafür, dass die Größe der inneren Elemente für verschiedene Auflösungen skaliert wird. Alle Größenangaben werden prozentual zu der Größe des Elternelements gemacht, damit die responsive Eigenschaft gewahrt bleibt(siehe Abb. \ref{fig:layout_container}).

\begin{figure}[htp]     % h=here, t=top, b=bottom, p=page
\centering
\includegraphics[width=1.0\textwidth]{images/layout_container}
\caption{Layout Container. Quelle: material.angularjs.org}\label{fig:layout_container}
\end{figure}

Die Fotogalerie (Abb. \ref{fig:gallery_large}, mittig) besteht aus jeweils einem Zeilencontainer pro Gruppierungsmonat der Aufnahmen. Die Zeilencontainer enthalten wiederum zwei weitere Container - die Monatsüberschrift und einen Gridcontainer \emph{md-grid-list} für die Fotokacheln.

Foto-Details-Metadaten (Abb. \ref{fig:form_normal}, rechts) befinden sich in einem von rechts ausklappbaren \emph{md-sidenav} Element. Es schiebt den Inhalt mit der Großansicht des Fotos weg und verdrängt es komplett auf kleinen Geräten. Die \emph{md-input} Formularfelder selbst lassen sich in einer Spalte als Zeilen anordnen.

Das Foto (Abb. \ref{fig:form_normal}, links) wird mit Hilfe der Flexbox \emph{justify-content} Eigenschaft zentriert. In Angular Material wird dies über den Parameter \emph{layout-align="center center"} auf dem Wrapper Container erreicht. Damit das Foto aber auch korrekt proportional zu seinen eigentlichen Dimensionen skaliert, müssen alle weiteren Elterncontainer des Imageelements 100\% ihrer verfügbaren Breite und Höhe einnehmen. Hierfür sorgt die Eigenschaft \emph{layout-fill}.

\section{Grund Setup}
\label{sec:grund_setup}

Um die \emph{Ajax-Engine} zu bündeln, kommt \gls{webpack} zum Einsatz. Dieses erlaubt das Zusammenbauen mehrerer öffentlicher (vendor) und eigener JavaScript-Module zu wenigen Buildfiles, welche bequem im Hauptmarkup eingebunden werden. Zudem wird dadurch ermöglicht, moderne JavaScript Syntax (e.g \gls{es2016}) durch Code Preprocessing durch sog. Transpiler zu verwenden. Ein solcher Transpiler wandelt z.B. einen modernen JavaScript Standard in einen ursprünglichen Standard, welcher von den Zielbrowsern der Anwendung bereits implementiert wurde, um.

Das Resultat eines solchen Builds ist eine einzige HTML-Seite \emph{index.html}, die der Benutzer am Ende ausgeliefert bekommt. Die Index Seite bettet wiederum nur zwei zusammengebaute Scripte aus allen bestehenden ein - \emph{index.bundle.css} und \emph{index.bundle.js}. Diese sind entsprechend für das gesamte Layout und die gesamte Business-Logik der Anwendung verantwortlich (siehe Quellcode \ref{lst:index_html}).

\begin{listing}[H]
\begin{minted}{html}
<!doctype html>

<head>
  <link rel="stylesheet" type="text/css" href="build/index.bundle.css">
  <title>Pika</title>
</head>
<body ng-app="pika">
...

<script src="build/vendor.bundle.js"></script>
<script src="build/index.bundle.js"></script>
</body>
</html>

\end{minted}
\caption{index.html}
\label{lst:index_html}
\end{listing}

\gls{webpack} setzt auf das in \emph{ES2015} eingeführte \emph{Modules}Feature auf. Hierbei wird ein Entryscript in der \gls{webpack}-Konfigurationsdatei deklariert (ähnlich dem Main File eines herkömmlichen Programms). \gls{webpack} durchläuft beim Build jedes darin importierte File rekursiv und lässt es anhand weiterer deklarierter Regeln durch entsprechende Präprozessoren verarbeiten. Sowohl Stylesheets als auch Skripte werden so verarbeitet. Der Output dieser Präprozessoren wird am Ende, wie in Quellcode \ref{lst:index_html} abgebildet, zu einzelnen Files gebündelt.

In Quellcode \ref{lst:webpack_config} ist ein Auszug aus der \emph{Pika} Build Konfiguration zum Transpilieren von \emph{ES2016} JavaScript Standard zu \emph{ES5} Standard mit Hilfe des \emph{babel-loader}, sowie von \gls{sass} zu \emph{CSS} mit Hilfe des \emph{sass-loader} dargestellt.

\begin{listing}[H]
\begin{minted}{javascript}
{
  entry: {
    index: ['./index.js']
  },
  module: {
    rules: [
      {test: /\.scss$/, use: ['sass-loader']},
      {test: /\.js$/, use: ['babel-loader']}
    ]
  }
}
\end{minted}
\caption{webpack.config.js}
\label{lst:webpack_config}
\end{listing}

Für diese Applikation werden insgesamt folgende Regeln deklariert:

\begin{itemize}
 \item Herkömmliche CSS-Bündelung aus anderen Paketen
 \item Statische Assets-Einbindung und Fingerprinting für besseres Browsercaching
 \item Präprozessing von \gls{es2016} zu \emph{ES5} für moderne JavaScript Features, z.B. Klassen, Modularisierung, Arrow Functions, Parameter Destructuring, Promises
 \item Präprozessing von \gls{sass} zu \emph{CSS} für erweitertes Stylesheet Tooling, wie Schachtelung, Vererbung, Variablen-Verwendung
 \item Präprozessing durch \gls{pug} (ehemal. \emph{Jade}) Templates zu HTML für bessere Markup Lesbarkeit
 \item Extrahierung des separaten \emph{CSS}-Bundles
 \item Trennung von Vendor und Applikation Codes in einzelne Bundles
\end{itemize}

Wie bereits oben erwähnt, bekommt der Benutzer eine einzelne Seite mit den gebündelten Skripten ausgeliefert. Der tatsächliche Inhalt der Applikation wird also erst durch das Bundle Skript auf dem Client erzeugt. Hierfür muss das AngularJS Framework wissen, welcher Platzhalter im DOM das Ziel des clientseitigen Renderings darstellen soll.

Quellcode \ref{lst:index_html} zeigt, dass der \emph{body} Tag hierfür mit dem entsprechenden Attribut \emph{ng-app="pika"} markiert worden ist. Man spricht hier auch von einer \gls{ng-directive}. Damit AngularJS die Kontrolle über den Inhalt des \emph{body} Tags übernehmen kann, ist schlussendlich der folgende Aufruf im \emph{index.js} File notwendig.

\begin{listing}[H]
\begin{minted}{javascript}
  import angular from 'angular';
  angular.module('pika', [
    //list of submodules
  ])
\end{minted}
\end{listing}

\section{Routing}
\label{sec:routing}

Da Pika immer noch eine Webanwendung ist und im Browser ausgeführt wird, erwarten Benutzer, dass das Navigieren zwischen einzelnen Bereichen der Applikation mit einer Veränderung der URL in der Adresszeile des Browsers einhergeht. Ebenfalls soll es möglich sein, zu einem bestimmten Bereich zu gelangen, indem man eine URL direkt in die Adresszeile des Browsers eingibt.

In \ref{sec:client_server} wurde jedoch erläutert, dass mit einer neuen Adresseingabe auch eine separate HTTP Anfrage verbunden ist. AngularJS bietet daher ein Routing Mechanismus an, welcher das Standardverhalten der Browser bei Adresseingaben kapert.

URL-Adresseingaben gehen zunächst durch den AngularJS Router in dem Client Code. Stellt dieser eine Adresse fest, welche in der Routingkonfiguration festgelegt wurde, so wird ein entsprechender Controller aufgerufen und seine Ausgabe in dem Hauptlayoutplatzhalter gerendert.


\begin{listing}[H]
\begin{minted}{html}
<body ng-app="pika" layout="row" layout-fill>
<div layout="column" layout-fill ng-cloak="">
  <side-menu />
  <ui-view role="main" layout="column" layout-fill></ui-view>
</div>
</body>
\end{minted}
\caption{Hauptlayout}
\label{lst:main_layout}
\end{listing}

Quellcode \ref{lst:main_layout} zeigt den restlichen Inhalt der \emph{index.html}-Datei. Entscheidend ist die Direktive \emph{ng-app="pika"}. Sie sorgt dafür, dass das in \emph{index.js} (Quellcode \ref{lst:module_build}) deklarierte Angular Hauptmodul das Rendering des Inhalts hier übernehmen kann.

Der Inhalt der Anwendung besteht aus den Direktiven für das Seitenmenü (\emph{side-menu} ) und dem jeweiligen Inhalt des Routers (\emph{ui-view}).

Letztendlich braucht das AngularJS Hauptmodul eine Konfiguration für das Routing von URLs zu den jeweiligen Hauptkontrollern der Applikation. Quellcode \ref{lst:routing_config} zeigt einen Auszug dieser Konfiguration. In dieser Arbeit wird ein 3rd Party Router, namens \emph{UI-Router} verwendet (Der Standardrouter ist bereits für den exemplarischen Anwendungsfall dieser Arbeit sehr eingeschränkt. Die Notwendigkeit für den UI-Router wird im weiteren Verlauf deutlich).

\begin{listing}[H]
\begin{minted}{javascript}
// routes.js
import photosTemplate from './photos/index.pug';
import photoDetailTemplate from './photo-detail/index.pug';

function routesConfig($stateProvider, $urlRouterProvider) {
  $stateProvider
    // ...
    .state('photos', {
      url: '/photos/:page?search',
      template: photosTemplate,
      controller: 'photosController',
      controllerAs: '$ctrl',
      resolve: { authenticate: authenticate }
    })
    .state('photo-detail', {
      url: '/photo-detail/:id',
      template: photoDetailTemplate,
      controller: 'photoDetailController',
      controllerAs: '$ctrl',
      resolve: { authenticate: authenticate }
    });
}

\end{minted}
\caption{Routing Konfiguration}
\label{lst:routing_config}
\end{listing}

Die obige Konfiguration definiert folgendes Verhalten: \\
Die Adresseingabe von \emph{https://pika.cloud/photos?page=7} führt zum Instanziieren des \emph{PhotosController}. Dieser rendert die Seite 7 der Fotogalerie in den \emph{ui-view}. Ein Klick auf den Link hinter der Miniansicht eines Bildes ruft die URL \emph{https://pika.cloud/photo-details/p13tr3} auf und sorgt entsprechend dafür, dass der \emph{PhotoDetailController} die Großansicht des Fotos mit der ID  \emph{p13tr3} rendert.

\section{Projekt Struktur}
\label{sec:project_structure}

Die Analyse der Aufgabestellung für diese Anwendung im Kapitel Design ergab die Hauptdomainbereiche -  Authentifizierung und Session Handling (\emph{session}), Menünavigation (\emph{side-menu}), Fotogalerie und Suche (\emph{photos}), Detail-Fotoansicht und Metadateneingabe (\emph{photo-detail}). Entsprechend dieser Domainbereiche wird die Modularisierung vorgenommen.

\subsection{Verzeichnis Struktur}

In zahlreichen Einstiegsquellen für Organisation von JavaScript Projekten findet man eine Bündelung nach Funktionsverantwortung der Komponenten im Angular Framework vor. So werden etwa Controller, Direktiven, Factories, Services in einzelnen Unterverzeichnissen organisiert. Dieser Aufbau hat den Nachteil, dass nicht sofort ersichtlich wird, wo sich der Applikationscode einer bestimmten Domain befindet, da er nun auf verschieden Orte verteilt ist.

Pika verwendet daher eine Gliederung der Verzeichnisse nach ihrer Domain. Diese Praxis wird unter JavaScript Entwicklern favorisiert \footnote{https://stackoverflow.com/questions/18542353/angularjs-folder-structure} und etwa in \cite{Kukic:2014} detailliert dargestellt. Es ergibt sich daher die Verzeichnis Struktur aus Quellcode \ref{lst:directorty_structure}.


\begin{listing}[H]
\begin{minted}{bash}
# Detail Fotoansicht und Metadateneingabe
|-- photo-detail
|   |-- controller.js
|   |-- form-component.js
|   |-- form.pug
|   |-- index.pug
|   |-- index.js
|   |-- index.scss
|   |-- toolbar-component.js
|   |-- toolbar.pug

# Foto Gallery und Suche
|-- photos
|   |-- client.js
|   |-- controller.js
|   |-- gallery.js
|   |-- index.pug
|   |-- index.js
|   |-- index.scss
|   |-- toolbar-component.js
|   |-- toolbar.pug

# Authentifizierung und Session Handling
|-- session
|   |-- controller.js
|   |-- index.js
|   |-- session.js

# Menünavigation
|-- side-menu
|   |-- index.pug
|   |-- index.js
|   `-- index.scss
|-- http-interceptor.js

# Übergreifender Code
|-- index.js
|-- index.scss
|-- routes.js
|-- theming.js
\end{minted}
\caption{Directory Structure}
\label{lst:directorty_structure}
\end{listing}

\subsection{Modul Struktur}

Entsprechend der Domain-Aufteilung lässt sich also jeder einzelne Bereich als ein einzelnes Angular Modul abbilden. Hierbei exportiert jedes einzelne Modul seine eigene Angular API Deklaration (siehe Quellcode \ref{lst:module_export}). Diese Exports werden schließlich im dem \emph{index.js} File an das \emph{Pika} Hauptmodul übergeben (siehe Quellcode \ref{lst:module_build}).


\begin{listing}[H]
\begin{minted}{javascript}
//photos/index.js
import angular from 'angular';

import client from './client';
import gallery from './gallery';
import controller from './controller';
import toolbarComponent from './toolbar-component.js';

export default angular.module('pika.photos', [
  client.name,
  gallery.name,
  controller.name,
  toolbarComponent.name
]);

\end{minted}
\caption{Modul Export}
\label{lst:module_export}
\end{listing}

\begin{listing}[H]
\begin{minted}{javascript}
//index.js
import session from './session';
import sideMenu from './side-menu';
import photos from './photos';
import photoDetail from './photo-detail';

angular.module('pika', [
  'ui.router',
  'ngMaterial',
  'ngFileUpload',
  sideMenu.name,
  session.name,
  photos.name,
  photoDetail.name
])
\end{minted}
\caption{Modul Zusammenbau}
\label{lst:module_build}
\end{listing}

\subsection{Komponenten Struktur}

Kapitel \ref{sec:architecture} erläutert das Paradigma des clientseitigen Javascript-MVC-Frameworks. Es liegt darin, einzelne Komponenten für Teilbereiche des HTML DOMs zu erstellen. Eine Komponente nimmt alle Benutzerinteraktionen in ihrem Teilbereich entgegen, speichert und rendert dessen Zustand.

Sie besteht aus mehreren weiteren Einheiten - einem View, einem Controller und einem bis zu mehreren Models. In dieser Arbeit nimmt der Controller, wie am Ende von  Kapitel \ref{sec:architecture} geschildert, eine Presenter Rolle ein. D.h. er speichert nicht nur die Rohdaten für die Darstellung, sondern exakt den Zustand des Benutzerinterfaces.

Angewendet auf dem Prozess der Fotogalerie Darstellung bedeutet es, dass der entsprechende \emph{PhotosController} die Daten exakt in der Form speichert, wie diese gerendert werden. Die Darstellung der Fotogalerie ist nach dem Monat der Aufnahme gruppiert. Die Rohdaten werden aber üblicherweise von einer Serverschnittselle als sortierte Liste zurückkommen. Es ist demnach die Aufgabe des Controllers in der Presenter Rolle, die Daten aus einer Liste gruppiert nach Aufnahmemonat abzulegen. Dafür kann er natürlich weitere Model Services hinzuziehen. Das View-Markup bleibt somit sehr schlicht. Dieses Vorgehen ergibt eine maximale Trennung von visueller Darstellung und Applikationslogik.

Komponenten in Angular können entweder durch URL Routing in einem Platzhalter ausgetauscht werden (siehe \ref{sec:routing}) oder direkt durch eine Angular Direktive als eine Art Custom HTML Tag instanziiert werden, falls sich ihr Verhalten nicht auf die URL Änderung auswirken muss.

Für diese Arbeit ergibt sich folgende generelle Komponenten Gliederung:

\begin{itemize}
\item Die vier Hauptdomainbereiche - \emph{session}, \emph{side-menu}, \emph{photos}, \emph{photo-details} - bilden entsprechende Komponente und bestehen aus einem Hauptcontroller und einem zugehörigen Markup-Template in \gls{pug} Syntax (mit Ausnahme von \emph{session}).
\item Photos- und PhotoDetails Controller werden über URL Routing angesprochen
\item Die Hauptbereiche besitzen weitere Komponenten Gliederungen, wie PhotoToolbar, PhotoDetails Toolbar, PhotoForm. Sie werden als Direktiven im Markup initialisiert.
\end{itemize}

\section{Session Handling}

\subsection{Grundverfahren}
\label{sec:session_handling_basics}

Kapitel \ref{sec:spec:authentication} definiert die Anforderung zur Benutzerauthentifizierung. Die Grundvorgehensweise dabei schildert sich wie folgt:

\begin{itemize}
  \item Der Benutzer gibt seine Anmeldedaten beim initialen Aufruf der Anwendung ein.
  \item Die Anmeldedaten werden auf dem Server validiert.
  \item Nach positiver Prüfung erhält der Benutzer einen Session Token.
  \item Der Client speichert den Session Token permanent ab.
  \item Der Session Token wird mit jeder weiteren Anfrage an den Server gesendet.
\end{itemize}

Das obige Vorgehen liefert den Grundsatz einer Lösung auf das in Kapitel \ref{sec:client_server} geschilderte Problem der Zustandsbehaftung in dem zustandslosen HTTP Protokoll. Jede HTTP Anfrage erhält durch die obige Technik schließlich einen eindeutigen Session Token, über den der Server den Benutzer authentifizieren kann.

Für die konkrete Implementierung existiert eine Reihe von Verfahren. Die einfachste Variante nutzt den Standard Cookie Mechanismus von HTTP, um den Session Token zu speichern. Wenn ein solcher Cookie vom Server gesetzt wurde, ist kein weiterer Client Code erforderlich, um diesen mit nachfolgenden Anfragen zu senden. Folglich ist es auch die ursprüngliche und einzige Variante, um rein serverseitige Webanwendungen zu authentifizieren.

Die Cookie Authentifizierung bietet allerdings die meiste Angriffsoberfläche. Aus diesem Grund verwenden eigenimplementierte Webclients in aller Regel einen separaten Mechanismus. Der  RFC 7519 Standard JWT taucht oft in Zusammenhang von Authentifizierung von Single Page Webapplikationen auf. Tatsächlich spezifiziert JWT nur den Aufbau- und Verifizierungsmechanismus der Session Token. Vgl. \cite[Kap. 1]{Peyrott:2018}

Für den tatsächlichen Authentifizierungsablauf bietet es lediglich Richtlinien an. In einfacher Form benötigt der Client kein Wissen darüber, welche Art von Token Standard auf dem Server verwendet wurde. Vgl. \cite[Kap. 2.2]{Peyrott:2018}. Daher zeigt diese Arbeit die Implementierung eines Authentifizierungsverfahrens, welches einer solchen Richtlinie aus dem JWT Standard folgt.

\subsection{Authentifizierung}

Den Aufruf der Root URL bearbeitet die \emph{SessionController\#index} Methode und rendert das Login Formular, wenn der Benutzer nicht eingeloggt ist (siehe Quellcode \ref{lst:session_handling}).

Die \emph{SessionController\#create} Methode nimmt die Anmeldedaten aus dem Login Formular entgegen. Daraufhin sendet der Controller \emph{POST '/api/session-token'} mit den Benutzereingaben an den Server. Sollte die Eingabe falsch sein, wird die Fehlermeldung aus der Antwort in einer Instanzvariable des Controllers abgelegt und per \gls{databinding} im Formular gerendert. Die gültige Antwort des Servers enthält ein JSON Objekt mit den Daten des gegenwärtigen Users inklusive des JWT Session Tokens.

Diese Daten müssen nun permanent abgelegt werden. Diese Aufgaben übernimmt das \emph{Session} Objekt. Der \emph{SessionController} leitet die Daten des gegenwärtigen Users an die \emph{Session\#authorize} Methode weiter. Darauf legt das Session Objekt diese über den \gls{localstorage} Mechanismus des Browsers ab.

Beim erneuten Instanziieren des Session Objekts liest dessen Konstruktor das Token aus dem LocalStorage. Wird der \emph{SessionController\#index} erneut aufgerufen, prüft der \emph{SessionController} über \emph{Session\#isAuthenticated}, ob ein \emph{User} Objekt bekannt ist, und übergibt das Rendering an den \emph{PhotosController}. Dies wird über die Router Schnittstelle \emph{this.\$state.go('photos')} erreicht. Der Befehl verändert die Adresszeile des Browsers auf die unter dem  \emph{photos} Schlüssel konfigurierte URL. Ebenfalls unter diesem Schlüssel in der Routerkonfiguration
wird festgelegt, dass der \emph{PhotosController} für die Navigation auf die obige URL zuständig ist. Angular sorgt dafür, dass der entsprechende Controller instanziiert wird und das Rendering übernimmt. Der Benutzer ist somit eingeloggt und sieht die Fotogalerie.

\begin{listing}[H]
\begin{minted}{javascript}
//session/controller.js
class SessionController {
  /** @ngInject */
  constructor($state, $http, session) {
    //...
  }

  index() {
    if (this.session.isAuthenticated()) {
      return this.$state.go('photos')
    }
  }

  create() {
    const _this = this;
    this.$http.post('/api/session-token', this.user)
    .then((response) => {
      _this.session.authenticate(response.data);
      _this.$state.go('photos');
    });
  }
}

export default angular.module('session.controller', [])
  .controller('sessionController', SessionController)


//session/session.js
class Session {

  constructor() {
    this.user = JSON.parse(localStorage.getItem('user')) || {};
  }

  authenticate(user) {
    this.user = user;
    localStorage.setItem('user', JSON.stringify(user));
  }

  isAuthenticated() {
    return !!this.user.token;
  }
}

export default angular.module('session.session', [])
  .service('session', Session)

\end{minted}
\caption{Session Handling}
\label{lst:session_handling}
\end{listing}

\subsection{Autorisierung}

Nachdem die erfolgreiche Authentifizierung des Users abgeschlossen ist, müssen einzelne Bereiche der Applikation nur für eingeloggte Nutzer autorisiert werden. Hierfür muss das Session Objekt für andere Komponenten im System verfügbar gemacht werden.

Solche Abhängigkeiten werden in AngularJS über das \gls{di} Mechanismus aufgelöst. Der DI-Con­tai­ner kümmert sich um die Instanziierung aller registrierten Objekte. Es kann hier festgelegt werden, ob eine Abhängigkeit nur ein Mal pro Modul als \gls{ng-service} verfügbar ist oder jedes Mal neu mit Hilfe einer \gls{ng-factory} instanziiert wird, wenn sie gebraucht wird.
Die \emph{Session} Klasse wird als Service registriert, da dessen Instanz mit den Userdaten über alle anfordernden Komponenten einmalig verfügbar sein muss.

Eine Stelle, wo der authentifizierte Zustand geprüft wird, ist der Router. Alle Routes im System müssen den Benutzer zurück auf das Login Formular weiterleiten, wenn dieser nicht eingeloggt ist (siehe Quellcode \ref{lst:route_authorization}).

\begin{listing}[H]
\begin{minted}{javascript}
//routes.js
function routesConfig($stateProvider, $urlRouterProvider) {
  $stateProvider
  // ...
    .state('photos', {
      url: '/photos/:page?search',
      template: photosTemplate,
      controller: 'photosController',
      controllerAs: '$ctrl',
      resolve: { authenticate: authenticate }
    })
  // ...
}

function authenticate($q, $state, $timeout, session) {
  if (session.isAuthenticated()) {
    return $q.when();
  }

  $timeout(function() {
    $state.go('session');
  })

  return $q.reject();
}

\end{minted}
\caption{Route Autorisierung}
\label{lst:route_authorization}
\end{listing}

Über das \emph{resolve} Keyword lässt sich in der Router Konfiguration eine \emph{authenticate} Funktion anhängen. Diese wird immer aufgerufen, wenn eine Routeänderung auf die entsprechende Route passiert. Der Rückgabewert dieser Funktion - ein erfolgreich/nicht erfolgreich aufgelöstes \gls{promise} Objekt - bestimmt darüber, ob die Routeänderung wirklich durchgeführt werden darf.

Diese Entscheidung kann die \emph{authenticate} Funktion einfach treffen, indem es die API des injecteten Session Objektes \emph{session.isAuthenticated()} in Anspruch nimmt.

Das oben beschriebene Verfahren der Route Autorisierung ist offensichtlich keine Sicherheitsmaßnahme, da das Ganze in dem Client Code passiert. Es dient, wie angedeutet, lediglich der notwendigen User Experience - der User soll immer auf das Login Formular umgeleitet werden, falls nicht richtig autorisiert.

Wie in Kapitel \ref{sec:session_handling_basics} geschildert, muss ein Server jede HTTP Anfrage auf das valide Session Token prüfen, da diese auch ohne des originalen Webclients von einem potentiellen Angreifer durchgeführt werden können. Das Session Objekt muss demnach bei allen HTTP Aufrufen bekannt sein.

Angular bringt einen HTTP Client mit, welcher lediglich einen bequemeren Wrapper über die native Browser \emph{fetch} API darstellt. Über einen sog. \emph{HTTP Interceptor} lässt sich das Setzen des nötigen Autorisierungheaders einmalig konfigurieren (siehe Quellcode \ref{lst:http_interceptor}).

\begin{listing}[H]
\begin{minted}{javascript}

//http-interceptor.js
export default function (session) {
  return {
    request: (config) => {
      if (session.isAuthenticated()) {
        config.headers.Authorization = `Bearer ${session.user.token}`;
      }
      return config;
    }
  };
};

\end{minted}
\caption{HTTP Interceptor}
\label{lst:http_interceptor}
\end{listing}

Die Abhängigkeit zu dem HTTP Client lässt sich über den von Angular mitgelieferten DI-Container auflösen. Nach der korrekten Registrierung des HTTP Interceptor muss bei der Benutzung des Clients nichts weiter beachtet werden (Siehe Quellcode \ref{lst:http_client}).

\begin{listing}[H]
\begin{minted}{javascript}

//photos/client.js
class PhotosClient {
  constructor($http {
    this.$http = $http;
  }

  // ...

  findById(id) {
    return this.$http.get(`/api/photos/${id}`);
  }

  // ...
}

\end{minted}
\caption{HTTP Client Verwendung}
\label{lst:http_client}
\end{listing}

\section{Menüführung}

In Kapitel \ref{sec:des:navigation_menu} wurde ein Seitenmenü für die Hauptnavigation der Applikation und jeweils ein Kontextmenü in der Tab-Leiste für die Unterbereiche, wie die Galerie- oder Photo-Detail-Ansicht, entworfen. Das Hauptseitenmenü bleibt während des gesamten Nutzererlebnisses unverändert, während die Kontextmenüs sich je nach Kontext ändern können.

In Quellcode \ref{lst:main_layout} wurde der Lösungsansatz für die Menüführung bereits deutlich. Die Applikation benötigt ein Hauptlayout bzw. ein übergreifendes Frame. Dieses Frame enthält das Seitenmenü, dessen Komponente über die \gls{ng-directive} \emph{side-menu} im Markup initialisiert wird. Neben dem Seitenmenü ist ein Platzhalter für die Unterbereiche, dessen Inhalt von dem Router bestimmt wird. Die verschiedenen Kontext Untermenüs hingegen werden von der jeweiligen Hauptkomponente als Direktive in Markup eingebunden. Dies hat den Grund, dass der Kontext sich mit dem Wechsel in einen Unterbereich unterscheidet. Die Fotogalerie benötigt beispielsweise ein Suchfeld, während die Detailansicht unter anderem ein Button für das Anzeigen der Metadaten enthält.

Die Implementierung des Seitenmenüs gestaltet sich recht trivial. Der SideMenuController (siehe Quellcode \ref{lst:side_menu_controller}) initialisiert Menüeinträge. Es sind lediglich Einträge mit Namen und URL-Route zu dem Unterbereich. Der Controller muss somit nicht auf die Navigation selbst reagieren, da diese von dem Router übernommen wird.

\begin{listing}[H]
\begin{minted}{javascript}

import angular from 'angular';
import template from './index.pug';

//side-menu/index.js
class SideMenuController {

  /** @ngInject */
  constructor($mdSidenav) {
    this.$mdSidenav = $mdSidenav;
    this.initMenu();
    this.initAdminMenu();
  }

  initMenu() {
    this.menu = [
      {
        link: '/photos',
        title: 'Photos',
        icon: 'image',
      },
      {
        link: '/settings',
        title: 'Settings',
        icon: 'settings',
      },
      //...
    ];
  }

  close() {
    this.$mdSidenav('left').close();
  }
}

export default angular.module('pika.side-menu', [])
  .component('sideMenu', {
    template: template(),
    controller: SideMenuController,
    controllerAs: 'sideMenuController',
  });


\end{minted}
\caption{SideMenuController}
\label{lst:side_menu_controller}
\end{listing}


\begin{listing}[H]
\begin{minted}{text}

//side-menu/index.pug
md-sidenav.md-sidenav-left()
  // ...
  md-content
    md-list(flex='')
      md-list-item(ng-repeat='item in sideMenuController.menu')
        md-icon.blue_grey-400.material-icons.step {{item.icon}}
        p a(href='item.link')
            {{item.title}}

    md-button(ng-click='sideMenuController.close()', class='md-primary')
      Close

\end{minted}
\caption{Side Menu View}
\label{lst:side_menu_view}
\end{listing}

Das Verhalten des Seitenmenüs inklusive der Ein- und Ausklappen Animation bringt die Angular \emph{mdSideNav} Komponente mit, welche schließlich im Markup erzeugt wird (siehe Quellcode \ref{lst:side_menu_view}). Paradoxerweise ist der SideMenuController nicht für das Ausklappen des Seitenmenüs zuständig. Diese Aufgabe übernehmen die Kontextmenüs. Dies hat den einfachen Grund, dass der Ausklappregler sich in dem jeweiligen Kontextmenü links und nicht in dem Seitenmenü selbst befindet. Der Button zum Ausklappen lässt sich ebenfalls in eine extra Komponente auslagern und in jede Kontext-Toolbar integrieren.

\section{Foto Galerie}
\label{sec:photo_gallery}

\subsection{Laden}

Die Fotogalerie ist ein Beispiel für die Kommunikation über mehrere Controller und Wiederverwendbarkeit von Models. Die Einzelansicht des Fotos ist ebenfalls ein Art Galerie, da hier ein Sliden zum nächsten und vorherigen Foto möglich ist. Beide Ansichten - Gallerie- und Einzelansicht - laden die Fotos stapelweise (siehe \ref{imp:pagination}). Dieses gemeinsame Verhalten für das Laden von Fotos wird an ein separates Model, die \emph{PhotosGallery} ausgelagert.

Das \emph{PhotosGallery} Objekt wird zwischen den \emph{PhotosController} und \emph{PhotoDetailsController} wiederverwendet. Es speichert den aktuell geladenen Stapel an Fotometadaten sowie das aktuell ausgewählte Foto. Das \emph{PhotosGallery} Objekt lädt einen entsprechenden Stapel an Fotos, wenn der Benutzer auf eine Galerieseite navigiert. Das Sliden zum nächsten Foto in der Einzelansicht geschieht innerhalb des geladenen Fotostapels. Will der Benutzer ein weiteres Foto betrachten als im Stapel verfügbar, geschieht das Nachladen über den selben Mechanismus des paginierten Ladens in der Fotogalerie.

 Der \emph{PhotosController} und der \emph{PhotoDetailsController} beobachten den Zustand des \emph{PhotosGallery} Objekts. Unabhängig davon, welcher der beiden Controller eine Zustandsänderung im \emph{PhotosGallery} Objekt ausgelöst hat, bleibt die Darstellung immer synchronisiert. Der Benutzer kann somit mehrere Fotobündel weit in der Einzelansicht sliden. Wenn er am Ende wieder in die Galerieansicht zurückkehrt, wird das aktuelle Fotobündel mit letztem betrachteten Foto dargestellt.

Die Navigation zu \emph{\/photos} URL rendert die Fotogalerie. Dies übernimmt  \emph{PhotosController\#showPhotos}. Der Controller deklariert eine Abhängigkeit auf die \emph{PhotosGallery}, welche wiederum über den \emph{PhotosClient} den HTTP GET Aufruf an den Server durchführt.

Die Antwort ist ein Array in \gls{json} Format mit Fotometadaten mit Titel, Beschreibung, diversen Kameraeinstellungen und der URL zu dem eigentlichen File. \gls{json} wird in JavaScript durch einen Aufruf von \emph{JSON.parse} direkt in ein Objekt umgewandelt. Der Angular HTTP Client macht es automatisch. Da die Darstellungslogik in den Controllern (Presentern) liegt, werden diese Rohdaten-Objekte direkt als Models verwendet, ohne extra Klassen dafür anzulegen. Die Fotometadaten werden in der Instanzvariable \emph{photos} in der \emph{PhotosGallery} abgelegt.


\begin{listing}[H]
\begin{minted}{javascript}
//photos/controller.js
class PhotosController {
  /** @ngInject */
  constructor($scope, $stateParams, $state, photosGallery) {
    // ...
    this.photosGallery = photosGallery;
    this.showPhotos();
  }

  showPhotos() {
    //...
    this.photosGallery.showPhotos({ search, page });
  }
}

//photos/gallery.js
class PhotosGallery {
  /** @ngInject */
  constructor(photosClient) {
    this.client = photosClient;
    this.photos = [];
    // ...
  }

  showPhotos({ search, page = 1 } = {}) {
    const _this = this;
    //...
    return this.client.find({ search, page }).then(res => {
      _this.photos = res.data.photos;
      //...
      return _this.photos;
    });
  }

}

\end{minted}
\caption{Photo Galerie}
\label{lst:photo_gallery}
\end{listing}

\subsection{Gruppieren}

Nachdem die Fotos erfolgreich in dem \emph{PhotosGallery} Service geladen wurden, müssen die Rohdaten für die eigentliche Darstellung verarbeitet werden. Dieses Kapitel zeigt die weitere Verarbeitung exemplarisch anhand automatisch nach dem Monatsdatum gruppierter Darstellung der Fotos.

Diese Logik ist spezifisch für die Galerieansicht und wird im PhotosController angewendet. Die Gruppierung der Photos muss mit jeder Änderung des Arrays in der \emph{PhotosGallery} passieren. Der \emph{PhotosController} trägt sich hierfür als Beobachter auf Änderungen des \emph{photos} Arrays im \emph{PhotosGallery} Service ein.

Nach einer Änderung des \emph{photos} Arrays in der \emph{PhotosGallery} führt der Controller eine Gruppierungsfunktion aus. Das Endresultat legt der Controller in einem eigenen assoziativen Objekt als separate Instanzvariable \emph{photosByMonth} mit Monatsnamen als Schlüssel und Fotos für den jeweiligen Monat als Array ab. Der View rendert die Monatsgruppen aus der neuen Instanzvariable in der natürlichen vorsortierten Schlüsselreihenfolge und die einzelnen Fotos der Gruppen in der Reihenfolge der Monatsgruppen-Arrays.

\begin{listing}[H]
\begin{minted}{javascript}
//photos/controller.js
class PhotosController {
  /** @ngInject */
  constructor($scope, $stateParams, $state, photosGallery) {
    // ...
    this.photosGallery = photosGallery;
    this.photos = {};

    this.showPhotos();
    this.initWatchers();
  }

  initWatchers() {
    this.$scope.$watch(
      () => { return this.photosGallery.photos },
      this.groupPhotosByMonth.bind(this)
    );
  }

  /* group the photos array to a key value object of month name to photos
   e.g. { 'Jan 2021' => [{id: 1,  ... }, {id: 2, ...}, ... }]
   */
  groupPhotosByMonth(photos) {
    const res = {};
    photos.forEach((photo) => {
      const month = this.monthLabel(photo);
      if (!res[month]) {
        res[month] = [];
      }

      res[month].push(photo);
    });
    this.photosByMonth = res;
  }
}

\end{minted}
\caption{Foto Gruppierung}
\label{lst:photo_group}
\end{listing}

\label{imp:pagination}
\subsection{Paginieren}

Für das Laden von Fotos in Stapeln wird in dem Benutzerinterface eine simple Paginierung verwendet. Es werden Links auf zwei vorherige und zwei folgende Seiten mit jeweils 50 Bildern angezeigt. E.g. [5, 6, 7, 8, 9].

Das Laden des nächsten Fotostapels passiert durch das Klicken des entsprechenden Seitenlinks und wird in der Browser-Adresszeile abgebildet. Es kann aber auch durch das Sliden zum nächsten bzw. vorherigen Foto in der Detailansicht passieren. Somit ist wiederum der PhotosGallery Service für die Paginierung verantwortlich.

Der PhotosClient, über den letztendlich die Daten angefragt werden, akzeptiert einen \emph{page} Parameter, welchen er per HTTP Query-Parameter wiederum an den Server senden kann. Basierend auf der aktuell angefragten Seite, generiert der \emph{PhotosGallery} Service ein Array aus Seitenzahlen in einer Instanzvariable nach jedem Laden eines Fotostapels.

Die Paginierung geschieht folgenderweise:

\begin{itemize}
  \item Der Benutzer lädt die \emph{/photos} URL ohne \emph{page} Parameter
  \item Der \emph{PhotosGallery} Service lädt den Initialbatch \emph{1} mit 50 Fotos
  \item Der \emph{PhotosGallery} Service generiert den ersten Bereich aus Seitenlinks [1,2,3,4,5]
  \item Der \emph{PhotosController} rendert die Fotos und die Seitenlinks
  \item Der Benutzer klickt auf einen der Links, z.B. 5
  \item Der \emph{PhotosController} nimmt die Aktion mit dem Seitenparameter entgegen, sorgt darauf für eine Routeänderung, welche die Seitenzahl enthält, z.B. \emph{\/photos\/5}
  (Dieser Schritt ist notwendig, damit sich die Seitenzahl ebenfalls in der Adresszeile widerspiegelt und damit auch über die Adresszeile navigiert werden kann).
  \item Der \emph{PhotosController} wird durch den Router neu initialisiert, liest den \emph{page} Parameter aus dem Router, fordert \emph{PhotosGallery} auf, den neuen Stapel zu laden
  \item Der \emph{PhotosGallery} Service fragt den entsprechenden Stapel vom \emph{PhotosClient} an, legt diesen in einer Instanzvariable ab, generiert neue Paginierungslinks
\end{itemize}

\begin{listing}[H]
\begin{minted}{javascript}
//photos/controller.js
class PhotosController {
  constructor(/**/) {
    //...
    this.showPhotos();
  }

  showPhotos() {
    const page = parseInt(this.$stateParams.page, 10) || undefined
    const search = this.$stateParams.search

    this.photosGallery.showPhotos({ page, search });
  }

  // triggered on page link click
  showPage(page) {
    this.$state.go(
      'photos',
      { page, search: this.photosGallery.search },
      { location: 'replace' }
    );
  }
}


//photos/gellery.js
class PhotosGallery {
  showPhotos({ search, page = 1 } = {}) {
    const _this = this;
    return this.client.find({ search, page }}).then(res => {
      _this.photos = res.data.photos;
      _this.totalSize = res.data.totalSize;
      _this.currentPage = page;
      _this.search = search;

      _this.paginate();
      return _this.photos;
    });
  }

  paginate() {
    let start = this.currentPage - 2;
    let end = start + 5;
    // ... handle edge cases ...
    this.pages = _.range(start, end);
  }
}

\end{minted}
\caption{Paginierung}
\label{lst:pagination}
\end{listing}

\subsection{Rendering}
\label{sec:rendering}

Das Markup der Fotogalerie ist ein logikfreies Rendering der oben erläuterten Datenstrukturen. Pro Monat der Aufnahmen wird eine GridList mit den Fotokacheln gerendert und unten auf der Seite eine Zeile mit den Paginierunglinks angehängt.
Pro Foto wird eine Grid-Kachel \emph{md-grid-tile} erstellt. Das Foto selbst ist ein CSS \emph{background-image} Attribut der Kachel. Die Kachel erhält ebenfalls eine \emph{ng-click} Direktive mit entsprechender Aktion und Foto-ID, um bei einem Klick auf das Foto auf die Detailansicht zu gelangen.

\begin{listing}[H]
\begin{minted}{text}
//photos/index.pug
photos-toolbar

md-content(...)
  div(ng-repeat='(monthLabel, photos) in $ctrl.photosByMonth')

    md-content(...) {{monthLabel}}

    md-grid-list(...)
      md-grid-tile(
        ng-repeat='photo in photos'
        ng-style="{'background-image': 'url(' + photo.src + ')'}"
        ng-click="$ctrl.showPhoto(photo._id)"
      )

  div(class='pagination', ...)
    md-button(
      ng-repeat='page in $ctrl.photosGallery.pages'
      ng-click='$ctrl.showPage(page)'
   ) {{page}}



\end{minted}
\caption{Foto Gallerie Markup}
\label{lst:photo_group_jade}
\end{listing}

\section{Foto Suche}

Die Fotosuche verwendet für die Darstellung den exakt gleichen Code aus Kapitel \ref{sec:photo_gallery}. Die einzige Erweiterung, welche für die Suchefunktion notwendig ist, ist eine Weitergabe eines Suchbegriffes an den \emph{PhotosGallery} Service und wiederum an den HTTP Aufruf im \emph{PhotosClient}.

Das Suchfeld wird in die galeriespezifische Toolbar platziert. Nach der Eingabe wird eine Routeänderung über den Angular Router erzwungen. Die Route führt wie in dem Standardfall auf den \emph{PhotosController}, enthält jedoch einen Suchbegriff im Route-Parameter, z.B. \emph{/photos?search=hamburg}.

Der \emph{PhotosController} liest beim Laden der Fotos, wie in Quellcode \ref{lst:pagination} gezeigt, durch die \emph{showPhotos} Methode zusätzlich den
\emph{search} Parameter aus. Dieser wird dann an \emph{PhotosGellary.showPhotos} weitergereicht.

Letzendlich ist die Aufgabe des Servers enttprechend ein gefiltertes Ergebnis zurückzugeben. Der Suchbegriff muss zusätzlich zwischengespeichert werden, damit die Paginierung den Suchfilter beachtet.

\section{Foto Details}
\label{sec:photo_details}

In Kapitel \ref{sec:rendering} wird erwähnt, dass jede Fotokachel eine Klickaktion zugewiesen bekommt, welche zur der Detailansicht eines Fotos führt. Diese Aktion wird vom \emph{PhotosController} verarbeitet und ist eine triviale Routeänderung auf den \emph{PhotoDetailController} mit entsprechenden Photo-ID-Parameter in der URL. Die Routeänderung sorgt dafür, dass der \emph{PhotoDetailController} neu instanziiert wird. Bei jedem Instanziieren lädt der \emph{PhotoDetailController} das entsprechende Foto aus dem  Photo-ID-Parameter. Der \emph{PhotoDetailController} verwendet ebenfalls wie der \emph{PhotosController} den \emph{PhotosGallery} Service, um die Daten für das einzelne Foto zu laden.

Im Standardfall hat der PhotosGallery Service die Daten für das einzelne Foto bereits in dem \emph{photos}-Array. Diese befinden sich dort aus der vorherigen Anfrage des \emph{PhotosController} für die Darstellung der Fotoübersicht. Da ein Fotostapel eine überschaubare Größe hat, reicht hier eine lineare Suche nach dem Eintrag mit den Fotos mit entsprechender ID. Das gefundene Fotoobjekt inklusive der Fotometadaten wird in der Instanzvariable \emph{currentPhoto} abgelegt und per Databinding gerendert.

Die Anzeige der Metadaten ist hinter einer weiteren, von rechts ausklappbaren Sidebar, (siehe \ref{fig:form_normal}) versteckt. Editierbare Werte wie der Titel und die Beschreibung werden in Formularfelder dargestellt. Ein bidirektionales Databinding kopiert die Benutzereingaben in die entsprechende Felder des \emph{currentPhoto}-Objekts.

Der PhotoDetailController registriert sich auf die \emph{onChanged }-Events der Formularfelder und sendet nach einem kurzem Timeout die neuen bekannten Daten an den Server mit Hilfe des \emph{PhotoClient} Objektes. Somit ergibt sich ein sog. \enquote{In Place Editing}-Benutzererlebnis.

\section{Foto Slider}
\label{sec:photo_slider}

Die Foto-Detailansicht bietet gleichzeitig das Sliden zur Detailansicht des nächsten Fotos an. Grundsätzlich wird das Sliden zum nächsten bzw. vorherigen Foto durch ein Inkrementieren bzw. Dekrementieren eines Indexes implementiert. Hierfür speichert das \emph{PhotosGallery}-Objekt den aktuellen Index (\emph{currentIndex}) des angezeigten Fotos im \emph{photos} Stapel.

Die Slide-Aktion zum nächsten bzw. vorherigen Foto ruft die \emph{PhotosGallery}-Methode \emph{next} bzw. \emph{prev} auf. Dies ist wiederum ein Aufruf von \emph{slide} mit einem positiven bzw. negativen Wert. Dabei wird \emph{currentIndex} um den Wert verändert und der berechnete \emph{nextIndex} mittels \emph{setIndex} gesetzt. \emph{setIndex} speichert gleichzetig die Referenz auf die Fotometadaten unter dem Index in der Variable \emph{currentPhoto}. Wenn sich der Wert von \emph{currentPhoto} ändert, sorgt Databinding für ein Rendering des entsprechenden Fotos (siehe Quellcode \ref{lst:sliding}).

 Ferner findet in \emph{slide} eine Ausnahmebehandlung statt, wenn der Index außerhalb der Grenzen des zwischengespeicherten Stapels an Fotos wandert. Es wird der nächste bzw. vorherige Stapel an Fotos geladen. Hierfür wird die \emph{PhotosGallery\#showPhotos} Methode aus Quellcode \ref{lst:pagination} wiederverwendet. \emph{showPhotos} wird nun mit dem entsprechenden Parameter \emph{page} der nächsten bzw. vorherigen Seite aufgerufen. Das Verfahren aus Quellcode \ref{lst:pagination} wird nun für den weiteren Stapel an Foto Metadaten wiederholt.

Der Pseudocode in Quellcode \ref{lst:sliding} veranschaulicht das Verfahren unter Verzicht auf die Details der asynchronen JavaScript Programmierung.

\begin{listing}[H]
\begin{minted}{javascript}
//photos/gallery.js
class PhotosGallery {
  showPhotos({ search, page = 1 } = {}) {
    /* ... */
  }

  // ...

  next() {
    return this.slide(1);
  }

  prev() {
    return this.slide(-1);
  }

  slide(step = 1) {
    const nextIndex = this.currentIndex + step;
    const nextPage = this.currentPage + Math.sign(step);

    if (this.isIndexValid(nextIndex)) {
      this.setIndex(nextIndex);
      return;
    }

    if (nextPage <= 0) {
      return;
    }

    this.showPhotos({ page: nextPage });
    // ...
    // reset index to 0 (for next) or photos.length - 1 for (prev)
  }

  isIndexValid(index) {
    return index >= 0 && index < this.photos.length;
  }

  setIndex(index) {
    this.currentPhoto = this.photos[index];
    this.currentIndex = index;
    // ...
  }

  // ...
}

\end{minted}
\caption{Sliding}
\label{lst:sliding}
\end{listing}
